var documenterSearchIndex = {"docs":
[{"location":"syslin/#Toolbox-(max,)-Linear-Systems","page":"API: (max,+) Linear system","title":"Toolbox (max,+) Linear Systems","text":"","category":"section"},{"location":"syslin/#(max,)-Linear-System-constructor","page":"API: (max,+) Linear system","title":"(max,+) Linear System constructor","text":"","category":"section"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"MaxPlus.MPSysLin","category":"page"},{"location":"syslin/#MaxPlus.MPSysLin","page":"API: (max,+) Linear system","title":"MaxPlus.MPSysLin","text":"MPSysLin(A::MPAbstractVecOrMat, B::MPAbstractVecOrMat, C::MPAbstractVecOrMat [, D::MPAbstractVecOrMat, [x0::MPAbstractVecOrMat]])\n\nStructure for state space representation of Max-Plus linear systems. Creation of max-plus dynamical linear systems in implicit state form:\n\n    X(n) = D ⨂ X(n) ⨁ A ⨂ X(n-1) ⨁ B ⨂ U(n),\n    Y(n) = C ⨂ X(n)\n\nMPSysLin is the equivalent to ScicosLab function mpsyslin. It accepts dense or sparse Max-Plus arrays. D and x0 can be omited: they will be filled with Max-Plus zeros ε.\n\nArguments\n\nA shall be squared.\nB shall has its row dimension in accordance with dimensions of A.\nC shall has its column dimension in accordance with dimensions of A.\nD shall has its dimension in accordance with dimensions of A.\nx0 shall has its dimensions in accordance with dimensions of A.\n\nSizes are checked and an error is thrown during the compilation.\n\nElements of the system can access directly ie. S.A, S.B, S.C, S.D, S.x0.\n\nExamples\n\njulia> S = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]), # Max-Plus matrix A\n                    MP([    0.0;      0;      0]), # Max-Plus column vector B\n                    MP([    0.0       0       0]), # Max-Plus row vector C\n                    mpeye(3, 3),                   # Max-Plus matrix D\n                    full(zeros(MP, 3, 1)))         # Max-Plus column vector x0\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 3×3 Max-Plus dense matrix:\n  0   .   .\n  .   0   .\n  .   .   0\n\nA = 3×3 Max-Plus dense matrix:\n  1   2   3\n  4   5   6\n  7   8   9\n\nB = 3-element Max-Plus vector:\n  0\n  0\n  0\n\nC = 1×3 Max-Plus dense matrix:\n  0   0   0\n\nx0 = 3-element Max-Plus vector:\n  .\n  .\n  .\n\njulia> typeof(S)\nMPSysLin\n\njulia> S.A\n3×3 Max-Plus dense matrix:\n  1   2   3\n  4   5   6\n  7   8   9\n\n\n\n\n\n","category":"type"},{"location":"syslin/#(max,)-Linear-System-operations","page":"API: (max,+) Linear system","title":"(max,+) Linear System operations","text":"","category":"section"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"MaxPlus.mpexplicit(S::MPSysLin)","category":"page"},{"location":"syslin/#MaxPlus.mpexplicit-Tuple{MPSysLin}","page":"API: (max,+) Linear system","title":"MaxPlus.mpexplicit","text":"mpexplicit(S::MPSysLin)\n\nConvert to an explicit linear system.\n\nExamples\n\njulia> S = MPSysLin(MP([1.0 2; 3 4]),\n                    MP([0.0; 0]),\n                    MP([0.0 0]),\n                    mpeye(Float64, 2,2))\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 2×2 Matrix{MP{Float64}}:\n  0   .\n  .   0\n\nA = 2×2 Matrix{MP{Float64}}:\n  1   2\n  3   4\n\nB = 2-element Vector{MP{Float64}}:\n  0\n  0\n\nC = 1×2 Matrix{MP{Float64}}:\n  0   0\n\nx0 = 2-element Vector{MP{Float64}}:\n  .\n  .\n\njulia> mpexplicit(S)\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 2×2 Matrix{MP{Float64}}:\n  0   .\n  .   0\n\nA = 2×2 Matrix{MP{Float64}}:\n  1   2\n  3   4\n\nB = 2-element Vector{MP{Float64}}:\n  0\n  0\n\nC = 1×2 Matrix{MP{Float64}}:\n  0   0\n\nx0 = 2-element Vector{MP{Float64}}:\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"MaxPlus.mpsimul(S::MPSysLin, u::MPAbstractVecOrMat, history::Bool)","category":"page"},{"location":"syslin/#MaxPlus.mpsimul-Tuple{MPSysLin, AbstractVecOrMat{MP}, Bool}","page":"API: (max,+) Linear system","title":"MaxPlus.mpsimul","text":"mpsimul(S::MPSysLin, u::MPAbstractVecOrMat, history::Bool)\n\nCompute states X of an autonomous linear max-plus system:\n\n    x(n+1) = A ⨂ x(n)`  for n = 0 .. k\n\nWhere:\n\nA is a system matrix\nx0 is a initial state vector,\nk is the number of iterations\nwhen history is set to true save all computed states, else return the last one.\n\nArguments\n\nu: inputs to inject in the system\nhistory: if true then return a vector holding all results, else return the last result.\n\nExamples\n\njulia> S = MPSysLin(MP([1.0 2; 3 4]),\n                    MP([0.0; 0]),\n                    MP([0.0 0]),\n                    mpeye(Float64, 2,2))\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 2×2 Matrix{MP{Float64}}:\n  0   .\n  .   0\n\nA = 2×2 Matrix{MP{Float64}}:\n  1   2\n  3   4\n\nB = 2-element Vector{MP{Float64}}:\n  0\n  0\n\nC = 1×2 Matrix{MP{Float64}}:\n  0   0\n\nx0 = 2-element Vector{MP{Float64}}:\n  .\n  .\n\njulia> mpsimul(S, MP(1:10))\n1×10 Array{MP{Float64},2}:\n 1  5  9  13  17  21  25  29  33  37\n\njulia> mpsimul(S1, MP(1:10), history=false)\n1×1 Array{MP{Float64},2}:\n 37\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:(+)(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.:+-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.:+","text":"Base.:(+)(y::MPSysLin, x::MPSysLin)\n\nParallel composition of two Max-Plus linear systems.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S1 + S2\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 6×6 Max-Plus dense matrix:\n  0   .   .   .   .   .\n  .   0   .   .   .   .\n  .   .   0   .   .   .\n  .   .   .   0   .   .\n  .   .   .   .   0   .\n  .   .   .   .   .   0\n\nA = 6×6 Max-Plus dense matrix:\n  1   2   3    .    .    .\n  4   5   6    .    .    .\n  7   8   9    .    .    .\n  .   .   .   10   11   12\n  .   .   .   13   14   15\n  .   .   .   16   17   18\n\nB = 6-element Max-Plus vector:\n  1\n  2\n  3\n  0\n  0\n  0\n\nC = 1×6 Max-Plus dense matrix:\n  4   5   6   0   0   0\n\nx0 = 6-element Max-Plus vector:\n  .\n  .\n  .\n  .\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:(*)(y::MPSysLin, x::MPSysLin)","category":"page"},{"location":"syslin/#Base.:*-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.:*","text":"Base.:(*)(y::MPSysLin, x::MPSysLin)\n\nSeries composition of two Max-Plus linear systems.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S1 * S2\nTODO\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:(|)(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.:|-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.:|","text":"Base.:(|)(y::MPSysLin, x::MPSysLin)\n\nDiagonal composition of two Max-Plus linear systems.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S1 | S2\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 6×6 Matrix{MP{Float64}}:\n  0   .   .   .   .   .\n  .   0   .   .   .   .\n  .   .   0   .   .   .\n  .   .   .   0   .   .\n  .   .   .   .   0   .\n  .   .   .   .   .   0\n\nA = 6×6 Matrix{MP{Float64}}:\n  1   2   3    .    .    .\n  4   5   6    .    .    .\n  7   8   9    .    .    .\n  .   .   .   10   11   12\n  .   .   .   13   14   15\n  .   .   .   16   17   18\n\nB = 6×2 Matrix{MP{Float64}}:\n  1   .\n  2   .\n  3   .\n  .   0\n  .   0\n  .   0\n\nC = 2×6 Matrix{MP{Float64}}:\n  4   5   6   .   .   .\n  .   .   .   0   0   0\n\nx0 = 6-element Vector{MP{Float64}}:\n  .\n  .\n  .\n  .\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:vcat(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.vcat-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.vcat","text":"Base.:vcat(x::MPSysLin, y::MPSysLin)\n\nComposition of two Max-Plus linear systems: inputs in common, concatenation of outputs.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> [S1 ; S2]\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 6×6 Matrix{MP{Float64}}:\n  0   .   .   .   .   .\n  .   0   .   .   .   .\n  .   .   0   .   .   .\n  .   .   .   0   .   .\n  .   .   .   .   0   .\n  .   .   .   .   .   0\n\nA = 6×6 Matrix{MP{Float64}}:\n  1   2   3    .    .    .\n  4   5   6    .    .    .\n  7   8   9    .    .    .\n  .   .   .   10   11   12\n  .   .   .   13   14   15\n  .   .   .   16   17   18\n\nB = 6-element Vector{MP{Float64}}:\n  1\n  2\n  3\n  0\n  0\n  0\n\nC = 2×6 Matrix{MP{Float64}}:\n  4   5   6   .   .   .\n  .   .   .   0   0   0\n\nx0 = 6-element Vector{MP{Float64}}:\n  .\n  .\n  .\n  .\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:hcat(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.hcat-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.hcat","text":"Base.:hcat(x::MPSysLin, y::MPSysLin)\n\nComposition of two Max-Plus linear systems: concatenation of inputs, addition of outputs.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> [S1 S2]\n\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 6×6 Matrix{MP{Float64}}:\n  0   .   .   .   .   .\n  .   0   .   .   .   .\n  .   .   0   .   .   .\n  .   .   .   0   .   .\n  .   .   .   .   0   .\n  .   .   .   .   .   0\n\nA = 6×6 Matrix{MP{Float64}}:\n  1   2   3    .    .    .\n  4   5   6    .    .    .\n  7   8   9    .    .    .\n  .   .   .   10   11   12\n  .   .   .   13   14   15\n  .   .   .   16   17   18\n\nB = 6×2 Matrix{MP{Float64}}:\n  1   .\n  2   .\n  3   .\n  .   0\n  .   0\n  .   0\n\nC = 1×6 Matrix{MP{Float64}}:\n  4   5   6   0   0   0\n\nx0 = 6-element Vector{MP{Float64}}:\n  .\n  .\n  .\n  .\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:(/)(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.:/-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.:/","text":"Base.:(/)(y::MPSysLin, x::MPSysLin)\n\nFeedback composition: computes mpstar(S1*S2)*S1 in state-space form.\n\nExamples\n\njulia> S1 = MPSysLin(MP([1.0 2 3;  4 5 6;  7 8 9]),\n                     MP([    1.0;      2;      3]),\n                     MP([    4.0       5       6]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S2 = MPSysLin(MP([10.0 11 12;  13 14 15;  16 17 18]),\n                     MP([    0.0;      0;      0]),\n                     MP([    0.0       0       0]),\n                     mpeye(3, 3),\n                     full(zeros(MP, 3, 1)));\n\njulia> S1 / S2\n\nImplicit dynamic linear Max-Plus system:\nImplicit dynamic linear Max-Plus system:\n  x(n) = D*x(n) + A*x(n-1) + B*u(n)\n  y(n) = C*x(n)\n  x(0) = x0\n\nwith:\nD = 6×6 Matrix{MP{Float64}}:\n  0   .   .   1   1   1\n  .   0   .   2   2   2\n  .   .   0   3   3   3\n  4   5   6   0   .   .\n  4   5   6   .   0   .\n  4   5   6   .   .   0\n\nA = 6×6 Matrix{MP{Float64}}:\n  1   2   3    .    .    .\n  4   5   6    .    .    .\n  7   8   9    .    .    .\n  .   .   .   10   11   12\n  .   .   .   13   14   15\n  .   .   .   16   17   18\n\nB = 6-element Vector{MP{Float64}}:\n  1\n  2\n  3\n  .\n  .\n  .\n\nC = 1×6 Matrix{MP{Float64}}:\n  4   5   6   .   .   .\n\nx0 = 6-element Vector{MP{Float64}}:\n  .\n  .\n  .\n  .\n  .\n  .\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.:(==)(x::MPSysLin, y::MPSysLin)","category":"page"},{"location":"syslin/#Base.:==-Tuple{MPSysLin, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.:==","text":"Base.:(==)(x::MPSysLin, y::MPSysLin)\n\nTest whether two Max-Plus linear system are equal. ```\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"MaxPlus.mpshow(io::IO, S::MPSysLin)","category":"page"},{"location":"syslin/#MaxPlus.mpshow-Tuple{IO, MPSysLin}","page":"API: (max,+) Linear system","title":"MaxPlus.mpshow","text":"mpshow(io::IO, S::MPSysLin)\n\nBase function for displaying a Max-Plus linear system.\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"Base.show(io::IO, S::MPSysLin)\nBase.show(io::IO, ::MIME\"text/plain\", S::MPSysLin)","category":"page"},{"location":"syslin/#Base.show-Tuple{IO, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.show","text":"show(io::IO, S::MPSysLin)\n\nDisplay a Max-Plus linear system.\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"syslin/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, MPSysLin}","page":"API: (max,+) Linear system","title":"Base.show","text":"show(io::IO, ::MIME\"text/plain\", S::MPSysLin)\n\nDisplay a Max-Plus linear system.\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"syslin/","page":"API: (max,+) Linear system","title":"API: (max,+) Linear system","text":"MaxPlus.LaTeX(S::MPSysLin)\nMaxPlus.LaTeX(io::IO, S::MPSysLin)","category":"page"},{"location":"syslin/#MaxPlus.LaTeX-Tuple{MPSysLin}","page":"API: (max,+) Linear system","title":"MaxPlus.LaTeX","text":"LaTeX(S::MPSysLin)\n\nReturn the LaTeX code as string from the given Max-Plus linear system.\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"syslin/#MaxPlus.LaTeX-Tuple{IO, MPSysLin}","page":"API: (max,+) Linear system","title":"MaxPlus.LaTeX","text":"LaTeX(io::IO, S::MPSysLin)\n\nDisplay the LaTeX code from the given Max-Plus linear system.\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"tests/#Unit-tests","page":"Non Regression Tests","title":"Unit tests","text":"","category":"section"},{"location":"tests/","page":"Non Regression Tests","title":"Non Regression Tests","text":"If Julia did not complain when installing this package and if you obtained a good result when typing MP(5), then your (max,+) toolbox has been correctly installed and seems to work correctly. To be totally sure, you can run unit tests with the following Julia command:","category":"page"},{"location":"tests/","page":"Non Regression Tests","title":"Non Regression Tests","text":"] activate .\ntest","category":"page"},{"location":"tests/","page":"Non Regression Tests","title":"Non Regression Tests","text":"Hope, you will see:","category":"page"},{"location":"tests/","page":"Non Regression Tests","title":"Non Regression Tests","text":"Testing Running tests...\nTesting MaxPlus tests passed","category":"page"},{"location":"portage/#Rosetta-Stone-for-converting-Scilab-function-names-to-Julia","page":"Portage: ScicosLab to Julia","title":"Rosetta Stone for converting Scilab function names to Julia","text":"","category":"section"},{"location":"portage/#(min,)-core-functions","page":"Portage: ScicosLab to Julia","title":"(min,+) core functions","text":"","category":"section"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"Scilab/ScicosLab/NSP does not implement (min,+) algebra natively.","category":"page"},{"location":"portage/#(max,)-core-functions","page":"Portage: ScicosLab to Julia","title":"(max,+) core functions","text":"","category":"section"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"In the Julia REPL, type ? and the name of the function to show its documentation and examples. Functions are given in the alphabetical order of ScicosLab functions.","category":"page"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"ScicosLab Julia Comment\nastarb astarb Return the x of the equation x = A x + b\n/ (division) Base.:(/) (max,+) division operator on scalar, dense or sparse matrix.\nfull full, dense, Array Transform a (max,+) sparse matrix to a (max,+) dense matrix.\nhoward howard mpeigen Return eigenvalues and eigenvectors from a sparse matrix using Howard algorithm.\ninv Base.inv, Base.:(^,-1) Compute the inverse of the (max,+) matrix\nkarp howard mpeigen Karp algorithm is not implemented since Howard algorithm is faster.\n LaTeX, show MIME\"text/latex\" Output a (max,+) matrix to LaTeX code.\n# (maxplus) MP Create a (max,+) number or dense array or sparse array.\n& (min) Base.min Return the min of two (max,+) scalars or matrix.\n- (minus) Base.:(-) (max,+) minus unary and binary operators on scalar, dense or sparse matrix.\nmnorm norm Compute the norm of a (max,+) dense or sparse matrix.\nmptrace tr Compute the trace of a (max,+) dense or sparse matrix.\npercent0, %0 Base.zero, zero, mp0, MaxPlus.ε Return the (max,+) element zero.\npercent1, %1 Base.one, one, mp1,mpe Return the (max,+) element one.\npercenteye, %eye eye Return the (max,+) identity matrix.\n mpI The diagonal elements used for creating (max,+) identity matrix.\npercentones, %ones ones Return the once (max,+) matrix or column vector.\npercenttop, %top mptop Return the min+ element zero.\npercentzeros, %zeros spzeros Return the zero (max,+) sparse matrix or column vector (Julia builtin).\n zeros Return the zero (max,+) dense matrix or column vector.\n+ (plus) Base.:(+) (max,+) plus operator on scalar, dense or sparse matrix.\nplus plus Compute the (max,+) matrix A^+\nplustimes plustimes Convert a (max,+) number or matrix to a standard number or matrix (where plus and times operators are the classic operators).\n^ (power) Base.:(^) Compute the power of a (max,+) number or matrix.\n Base.show Display a (max,+) number or sparse or dense matrix.\n SparseArrays.sparse Create a (max,+) sparse matrix or convert a (max,+) dense matrix.\n\\ (residu) Base.:(\\) Return the x of the equation A x = b\nsemihoward semihoward Critical cycles\nstar star Compute the (max,+) matrix A^*\n* (times) Base.:(*) (max,+) times operator on scalar, dense or sparse matrix.\ntypeof Base.typeof Return the type of the (max,+) number.","category":"page"},{"location":"portage/#Dynamic-linear-(max,)-system","page":"Portage: ScicosLab to Julia","title":"Dynamic linear (max,+) system","text":"","category":"section"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"ScicosLab Julia Comment\nmpsyslin MPSysLin Structure holding state matrices of the syslin. In Scilab its a function.\n LaTeX Output a (max,+) syslin to a LaTeX formula.\nsimul mpsimul Simulation of the (max,+) linear system.\nexplicit mpexplicit Conversion of an implicit dynamic linear (max,+) system to an explicit form (where D state matrix is zero'ed).\n Base.show Display the (max,+) syslin.\nplus, + Base.:(+) (max,+) plus operator, or product with a (max,+) scalar or (max,+) matrix.\ntimes, * Base.:(*) Series composition.\n  Base.:(\n/. Base.:(/) Feedback composition.\n[;] Base.:vcat, [;] Inputs in common and concatenation of outputs.\n[,] Base.:hcat, [,] Concatenation of inputs and addition of outputs.\ntypeof typeof Return the type of the (max,+) syslin.","category":"page"},{"location":"portage/#Flowshop","page":"Portage: ScicosLab to Julia","title":"Flowshop","text":"","category":"section"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"ScicosLab Julia Comment\nflowshop  Flowshop maxplus linear system builder.\n LaTeX Generate the flowshop graph as a LaTeX formula.\nflowshop_graph  Flowshop graph builder.\nflowshop_simu  Maxplus linear system simulation.\nsaturation_graph  Saturation graph.\nshowcrgraph  Flowshop critical graph.\nstrongconnexgraph  Strong connected component extracting.","category":"page"},{"location":"portage/#Incompatibility","page":"Portage: ScicosLab to Julia","title":"Incompatibility","text":"","category":"section"},{"location":"portage/","page":"Portage: ScicosLab to Julia","title":"Portage: ScicosLab to Julia","text":"Function ScicosLab NSP Julia Comment\nlength(mpzeros(2,2)) 2 4 4 4 is the correct answer\nnorm, trace, min not implemented not implemented implemented \nMP^(-x) not implemented not implemented implemented Negative power (x > 0)","category":"page"},{"location":"minplus/#API:-(min,)-Algebra","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"","category":"section"},{"location":"minplus/#(min,)-constructor","page":"API: (min,+) Algebra","title":"(min,+) constructor","text":"","category":"section"},{"location":"minplus/#Scalar-Constructors","page":"API: (min,+) Algebra","title":"Scalar Constructors","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::Float64)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::Bool)","category":"page"},{"location":"minplus/#Dense-Matrix-and-Dense-Vector-Constructors","page":"API: (min,+) Algebra","title":"Dense Matrix and Dense Vector Constructors","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::Array)","category":"page"},{"location":"minplus/#Sparse-Matrix-Constructors","page":"API: (min,+) Algebra","title":"Sparse Matrix Constructors","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::SparseMatrixCSC)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(I::AbstractVector, J::AbstractVector, V::AbstractVector)","category":"page"},{"location":"minplus/#Sparse-Vector-Constructors","page":"API: (min,+) Algebra","title":"Sparse Vector Constructors","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::SparseVector)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(I::AbstractVector, V::AbstractVector)","category":"page"},{"location":"minplus/#Unit-Range-Constructors","page":"API: (min,+) Algebra","title":"Unit Range Constructors","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::UnitRange)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MI(::StepRangeLen)","category":"page"},{"location":"minplus/#Overloaded-Algebraic-Operators","page":"API: (min,+) Algebra","title":"Overloaded Algebraic Operators","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.zero(::MI)\nBase.zero(::Type{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.one(::MI)\nBase.one(::Type{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(+)(::MI, ::MI)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(*)(::MI, ::MI)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(^)(::MI, ::Number)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(/)(::MI, ::MI)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(\\)(::MI, ::MI)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(-)(::MI, ::MI)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:min(x::MI, y::MI)","category":"page"},{"location":"minplus/#(min,)-algebra-to-classic-algebra-conversion","page":"API: (min,+) Algebra","title":"(min,+) algebra to classic algebra conversion","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.plustimes(::MI)","category":"page"},{"location":"minplus/#(min,)-Constants","page":"API: (min,+) Algebra","title":"(min,+) Constants","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.mi0","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.mi1","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.mie","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.mitop","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.miI","category":"page"},{"location":"minplus/#(min,)-Dense-matrices-constructions","page":"API: (min,+) Algebra","title":"(min,+) Dense matrices constructions","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.ones(MI, m::Int64, n::Int64)\nBase.ones(MI, n::Int64)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.zeros(MI, m::Int64, n::Int64)\nBase.zeros(MI, n::Int64)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.eye(MI, m::Int64, n::Int64)\nMaxPlus.eye(MI, n::Int64)","category":"page"},{"location":"minplus/#(min,)-Sparse-matrices-constructions","page":"API: (min,+) Algebra","title":"(min,+) Sparse matrices constructions","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"SparseArrays.spzeros(MI, m::Int64, n::Int64)\nSparseArrays.spzeros(MI, n::Int64)","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.speye(MI, m::Int64, n::Int64)\nMaxPlus.speye(MI, n::Int64)","category":"page"},{"location":"minplus/#(min,)-matrices-Conversion","page":"API: (min,+) Algebra","title":"(min,+) matrices Conversion","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.plustimes(A::Array{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.plustimes(S::SparseMatrixCSC{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.full(S::SparseMatrixCSC{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.dense(S::SparseMatrixCSC{MI})","category":"page"},{"location":"minplus/#(min,)-Matrix-operations","page":"API: (min,+) Algebra","title":"(min,+) Matrix operations","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(\\)(::AbstractMatrix{MI}, ::AbstractMatrix{MI})\nBase.:(\\)(::AbstractMatrix{MI}, ::MI)\nBase.:(\\)(::MI, ::AbstractMatrix{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.:(/)(::AbstractMatrix{MI}, ::AbstractMatrix{MI})\nBase.:(/)(::AbstractMatrix{MI}, ::MI)\nBase.:(/)(::MI, ::AbstractMatrix{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"Base.inv(::Matrix{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.star(A::Array{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.plus(A::Array{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.astarb(A::Array{MI}, b::Array{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.MIeigen","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.howard(S::SparseMatrixCSC{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.tr(A::Array{MI})","category":"page"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.norm(A::Array{MI})","category":"page"},{"location":"minplus/#LinearAlgebra.norm-Tuple{Array{MI, N} where N}","page":"API: (min,+) Algebra","title":"LinearAlgebra.norm","text":"norm(A::Array{MP})\n\nCompute the norm of the full or sparce matrix A. Return the largest entry minus smallest entry of A.\n\nExamples\n\njulia-repl\njulia> using SparseArrays\n\njulia> A = MP([1 20 2;30 400 4;4 50 10])\n3×3 (max,+) dense matrix:\n   1.0    20.0    2.0\n  30.0   400.0    4.0\n   4.0    50.0   10.0\n\njulia> S = MP(sparse(A))\n3×3 (max,+) sparse matrix with 9 stored entries:\n   1    20    2\n  30   400    4\n   4    50   10\n\njulia> mpnorm(A)\n(max,+) 399\n\njulia> mpnorm(S)\n(max,+) 399\n\n\n\n\n\n","category":"method"},{"location":"minplus/#Display-control-of-(min,)-scalar-and-Matrices","page":"API: (min,+) Algebra","title":"Display control of (min,+) scalar and Matrices","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"MaxPlus.set_tropical_display\nMaxPlus.LaTeX(io::IO, A::Matrix{MI})\n\n#Base.show(::IO, ::Matrix{MI})\n#Base.show(::IO, ::SparseMatrixCSC{MI})\n\nBase.show(::IO, ::MIME\"text/plain\", A::Matrix{MI})\nBase.show(::IO, ::MIME\"text/latex\", A::Matrix{MI})","category":"page"},{"location":"minplus/#Index","page":"API: (min,+) Algebra","title":"Index","text":"","category":"section"},{"location":"minplus/","page":"API: (min,+) Algebra","title":"API: (min,+) Algebra","text":"","category":"page"},{"location":"maxplus/#API:-(max,)-Algebra","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"","category":"section"},{"location":"maxplus/#(max,)-constructor","page":"API: (max,+) Algebra","title":"(max,+) constructor","text":"","category":"section"},{"location":"maxplus/#Scalar-Constructors","page":"API: (max,+) Algebra","title":"Scalar Constructors","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::Float64)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{Float64}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(x::Float64)\nMP(x::Int64)\nMP(x::MP)\nMP(x::MI)\n\nImmutable Julia structure for creating a (max,+) scalar. This promotes the given number (Float64 or Int64 or MaxPlus or MinPlus) to a number in the tropical semi-ring (max, +) (ℝ ∪ {-∞}, ⨁, ⨂) where ℝ is the domain of reals, ⨁ is the usual multiplication and ⨂ is the usual maximum.\n\nNotes\n\nMP(3) is the equivalent to ScicosLab code: #(3)\n\nExamples\n\njulia> a = MP(3.5)\n(max,+) 3.5\n\njulia> typeof(a)\nMP (alias for Trop{MaxPlus.Max})\n\njulia> a = MP(3)\n(max,+) 3\n\njulia> typeof(a)\nMP (alias for Trop{MaxPlus.Max})\n\njulia> MP(MI(3.5))\n(max,+) 3.5\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::Bool)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{Bool}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(b::Bool)\n\nImmutable Julia structure for promoting the given Boolean value to an neutral number in the tropical semi-ring (max, +). This constructor does not make sense mathematically speaking but it is needed by Julia for defining the identity operator (max, +) LinearAlgebra.I.  Without this method, Julia will not be able to create correctly (max,+) identity matrices.\n\nExamples\n\njulia> set_tropical_display(0)\n\njulia> MP(true)\n(max,+) 0.0\n\njulia> MP(false)\n(max,+) -Inf\n\njulia> using LinearAlgebra\n\njulia> I\nUniformScaling{Bool}\ntrue*I\n\njulia> Matrix{MP}(I, 2, 2)\n2×2 (max,+) dense matrix:\n   0.0   -Inf\n  -Inf    0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Dense-Matrix-and-Dense-Vector-Constructors","page":"API: (max,+) Algebra","title":"Dense Matrix and Dense Vector Constructors","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::Array)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{Array}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(A::Array{Float64})\nMP(A::Array{Int64})\nMP(A::Array{MP})\nMP(A::Array{MI})\n\nPromote the given dense array of elements either from classic algebra (Float64 or Int64) or array of Max-Plus or Min-Plus elements to a dense array of tropical semi-ring (max, +) numbers.\n\nNote: if the array already contains at least one (max,+) element then the MP() is not necessary since (max,+) numbers contaminate other Float64 or Int64 numbers.\n\nExample where the MP() constructor is needed\n\njulia> A = MP([1.0 -Inf; 0.0 4])\n2×2 (max,+) dense matrix:\n  1   .\n  0   4\n\njulia> typeof(A)\nMatrix{MP} (alias for Array{Trop{MaxPlus.Max}, 2}\n\nExample where the MP() constructor is not needed\n\njulia> A = [MP(1.0) -Inf; 0.0 4]\n2×2 (max,+) dense matrix:\n  1   .\n  0   4\n\njulia> typeof(A)\nMatrix{MP} (alias for Array{Trop{MaxPlus.Max}, 2})\n\njulia> MP(MI([1.0 -Inf; 0.0 4]))\n2×2 (max,+) dense matrix:\n  1.0   -Inf\n  0.0    4.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Sparse-Matrix-Constructors","page":"API: (max,+) Algebra","title":"Sparse Matrix Constructors","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::SparseMatrixCSC)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{SparseMatrixCSC}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(S::SparseMatrixCSC{Float64})\nMP(S::SparseMatrixCSC{Int64})\nMP(S::SparseMatrixCSC{MP})\nMP(S::SparseMatrixCSC{MI})\n\nPromote the given sparse matrix of elements from classic algebra (Float64 or Int64) to a sparse array of tropical semi-ring (max, +) numbers. Also accept to promote elements from tropical semi-ring (max, +). By default, and following Julia rules, explicit (max,+) zeros (ε, mp0, MP(-Inf)) are not removed. You shall call dropzeros() to remove them.\n\nExamples\n\njulia> using SparseArrays\n\njulia> A = MP(sparse([1, 2, 3], [1, 2, 3], [-Inf, 2, 0]))\n3×3 (max,+) sparse matrix with 3 stored entries:\n  [1, 1]  =  .\n  [2, 2]  =  2\n  [3, 3]  =  0\n\njulia> dropzeros(A)\n3×3 (max,+) sparse matrix with 2 stored entries:\n  [2, 2]  =  2\n  [3, 3]  =  0\n\njulia> A = sparse([1, 2, 3], [1, 2, 3], MP([-Inf, 2, 0]))\n3×3 (max,+) sparse matrix with 3 stored entries:\n  [1, 1]  =  .\n  [2, 2]  =  2\n  [3, 3]  =  0\n\njulia> dropzeros(A)\n3×3 (max,+) sparse matrix with 2 stored entries:\n  [2, 2]  =  2\n  [3, 3]  =  0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(I::AbstractVector, J::AbstractVector, V::AbstractVector)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{T} where T}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(I::AbstractVector, J::AbstractVector, V::AbstractVector{Float64})\nMP(I::AbstractVector, J::AbstractVector, V::AbstractVector{Int64})\nMP(I::AbstractVector, J::AbstractVector, V::AbstractVector{MP})\nMP(I::AbstractVector, J::AbstractVector, V::AbstractVector{MI})\n\nConstruct a sparse CSC matrix of tropical semi-ring (max, +) elements from classic algebra (Float64 or Int64) to a sparse array of tropical semi-ring (max, +) numbers. Also accept to promote elements from tropical semi-ring (max, +). Note that zeros elements (ε, mp0, MP(-Inf)) are removed.\n\nElements are stored as: S[I[k], J[k]] = V[k] where elements of V are typed of Float64 or Int64 or MP.\n\nExamples\n\njulia> A = MP([1; 2; 3], [1; 2; 3], [42.5; -Inf; 44])\n3×3 (max,+) sparse matrix with 2 stored entries:\n  [1, 1]  =  42.5\n  [3, 3]  =  44\n\njulia> A = MP([1; 2; 3], [1; 2; 3], MP([42.5; -Inf; 44]))\n3×3 (max,+) sparse matrix with 2 stored entries:\n  [1, 1]  =  42.5\n  [3, 3]  =  44\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Sparse-Vector-Constructors","page":"API: (max,+) Algebra","title":"Sparse Vector Constructors","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::SparseVector)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{SparseVector}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(V::SparseVector{Float64})\nMP(V::SparseVector{Int64})\nMP(V::SparseVector{MP})\nMP(V::SparseVector{MI})\n\nConvert a sparse vector of tropical semi-ring (max, +) elements from given classic algebra to a (max,+) sparse vector. By default, explicit (max,+) zeros (ε, mp0, MP(-Inf)) are removed.\n\nExamples\n\njulia> MP(sparse([1.0, 0.0, 1.0]))\n3-element SparseVector{MP, Int64} with 2 stored entries:\n  [1]  =  1\n  [3]  =  1\n\njulia> A = sparse(MP([1; -Inf; 3]))\n3-element SparseVector{MP, Int64} with 2 stored entries:\n  [1]  =  1\n  [3]  =  3\n\njulia> A = MP(sparse([1; -Inf; 3]))\n3-element SparseVector{MP, Int64} with 3 stored entries:\n  [1]  =  1\n  [2]  =  .\n  [3]  =  3\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(I::AbstractVector, V::AbstractVector)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(I::AbstractVector, V::AbstractVector{Float64})\nMP(I::AbstractVector, V::AbstractVector{Int64})\nMP(I::AbstractVector, V::AbstractVector{MP})\nMP(I::AbstractVector, V::AbstractVector{MI})\n\nConstruct a sparse (max,+) vector such as S[I[k]] = V[k]. Explicit (max,+) zeros (ε, mp0, MP(-Inf)) are removed.\n\nExamples\n\njulia> A = MP([1; 2; 3], [42.5; -Inf; 44])\n3-element (max,+) sparse vector with 2 stored entries:\n  [1]  =  42.5\n  [3]  =  44\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Unit-Range-Constructors","page":"API: (max,+) Algebra","title":"Unit Range Constructors","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::UnitRange)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{UnitRange}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(x::UnitRange)\n\nCreate a (max,+) dense column vector from a given range.\n\nExamples\n\njulia> MP(1:3)\n3-element (max,+) vector:\n  1\n  2\n  3\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.MP(::StepRangeLen)","category":"page"},{"location":"maxplus/#MaxPlus.MP-Tuple{StepRangeLen}","page":"API: (max,+) Algebra","title":"MaxPlus.MP","text":"MP(x::StepRangeLen)\n\nCreate a (max,+) dense column vector from a given range.\n\nExamples\n\njulia> MP(1.0:0.5:3.0)\n5-element (max,+) vector:\n    1\n  1.5\n    2\n  2.5\n    3\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Overloaded-Algebraic-Operators","page":"API: (max,+) Algebra","title":"Overloaded Algebraic Operators","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.zero(::MP)\nBase.zero(::Type{MP})","category":"page"},{"location":"maxplus/#Base.zero-Tuple{MP}","page":"API: (max,+) Algebra","title":"Base.zero","text":"zero(::MP)\n\nCreate the constant (max,+) zero equals to -∞ (minus infinity) in classic algebra which is the neutral for the ⨁ operator. See also mp0 and ε.\n\nExamples\n\njulia> zero(MP)\n(max,+) -Inf\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.zero-Tuple{Type{MP}}","page":"API: (max,+) Algebra","title":"Base.zero","text":"zero(::Type{MP})\n\nCreate the constant (max,+) zero equals to -∞ (minus infinity) in classic algebra which is the neutral for the ⨁ operator. See also mp0 and ε.\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.one(::MP)\nBase.one(::Type{MP})","category":"page"},{"location":"maxplus/#Base.one-Tuple{MP}","page":"API: (max,+) Algebra","title":"Base.one","text":"one(::MP)\n\nCreate the constant (max,+) one equals to 0.0 (zero) in classic algebra which is the neutral for operators ⨁ and ⨂. See also mp1 and mpe.\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.one-Tuple{Type{MP}}","page":"API: (max,+) Algebra","title":"Base.one","text":"one(::Type{MP})\n\nCreate the constant (max,+) one equals to 0.0 (zero) in classic algebra which is the neutral for operators ⨁ and ⨂. See also mp1 and mpe.\n\nExamples\n\njulia> one(MP)\n(max,+) 0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(+)(::MP, ::MP)","category":"page"},{"location":"maxplus/#Base.:+-Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.:+","text":"+(x::MP, y::MP)\n\n(max,+) operator ⨁. Return the maximum of x and y as (max,+) type. At least one parameter shall be a (max,+) number (the other can be typed of Float64 or Int64 and its conversion to a (max,+) number is automatic).\n\nExamples\n\njulia> MP(1.0) + MP(3.0)\n(max,+) 3\n\njulia> MP(1.0) + 3\n(max,+) 3\n\njulia> 1 + MP(3.0)\n(max,+) 3\n\njulia> MP(3.0) + -Inf\n(max,+) 3\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(*)(::MP, ::MP)","category":"page"},{"location":"maxplus/#Base.:*-Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.:*","text":"*(x::MP, y::MP)\n\n(max,+) operator ⨂. Return the sum of x and y as (max,+) type. At least one parameter shall be a (max,+) number (the other can be typed of Float64 or Int64 and its conversion to a (max,+) number is automatic).\n\nExamples\n\njulia> MP(1.0) * MP(3.0)\n(max,+) 4\n\njulia> MP(1.0) * 3\n(max,+) 4\n\njulia> 1 * MP(3.0)\n(max,+) 4\n\njulia> set_tropical_display(0)\n\njulia> MP(1.0) * -Inf\n(max,+) -Inf\n\njulia> set_tropical_display(1)\n\njulia> MP(1.0) * -Inf\n(max,+) .\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(^)(::MP, ::Number)","category":"page"},{"location":"maxplus/#Base.:^-Tuple{MP, Number}","page":"API: (max,+) Algebra","title":"Base.:^","text":"Base.:(^)(::MP, ::Number)\n\nIn (max,+) algebra the power operator behaves like a multiplication in classical algebra.\n\nExamples\n\njulia> MP(2)^5\n(max,+) 10\n\njulia> MP(2)^-1\n(max,+) -2\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(/)(::MP, ::MP)","category":"page"},{"location":"maxplus/#Base.:/-Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.:/","text":"/(x::MP, y::MP)\n\nDivisor operator. Return the difference between x and y in classic algebra.\n\nx / y ≜ (x ⨂ y^-1)^-1\n\nExamples\n\njulia> MP(1.0) / MP(2.0)\n(max,+) -1\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(\\)(::MP, ::MP)","category":"page"},{"location":"maxplus/#Base.:\\-Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.:\\","text":"Base.:(\\)(x::MP, y::MP)\n\nDivisor operator. Return the difference between y and x in classic algebra.\n\nx \\ y ≜ (y^-1 ⨂ x)^-1\n\nExamples\n\n\njulia> MP(2) \\ MP(3)\n(max,+) 1\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(-)(::MP, ::MP)","category":"page"},{"location":"maxplus/#Base.:--Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.:-","text":"-(x::MP, y::MP)\n\nThe minus operator is not used in (max,+) algebra. Calling this operator will throw an error. Use the operator / to return the difference between x and y.\n\nExamples\n\njulia> MP(1.0) - MP(2.0)\nERROR: Minus operator does not exist in (max,+) algebra\n\njulia> MP(1.0) / MP(0.0)\n(max,+) 1.0\n\njulia> MP(1.0) / mp0\n(max,+) Inf\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:min(x::MP, y::MP)","category":"page"},{"location":"maxplus/#Base.min-Tuple{MP, MP}","page":"API: (max,+) Algebra","title":"Base.min","text":"min(x::MP, y::MP)\n\nReturn the minimun of (max,+) numbers x and y.\n\nmin(x, y) ≜ (x ⨂ y) ⨸ (x ⨁ y)\n\nExamples\n\njulia> min(MP(1), 3)\n(max,+) 1\n\njulia> min(MP([10 1; 10 1]), MP([4 5; 6 5]))\n2×2 (max,+) dense matrix:\n  4   1\n  6   1\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#(max,)-algebra-to-classic-algebra-conversion","page":"API: (max,+) Algebra","title":"(max,+) algebra to classic algebra conversion","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.plustimes(::MP)","category":"page"},{"location":"maxplus/#MaxPlus.plustimes-Tuple{MP}","page":"API: (max,+) Algebra","title":"MaxPlus.plustimes","text":"plustimes(x::MP)\n\nConvert a (max,+) number to a number in standard algebra. An alternative way could be x.λ.\n\nExamples\n\njulia> plustimes(MP(1.0))\n1.0\n\njulia> typeof(plustimes(MP(1)))\nFloat64\n\njulia> x = MP(1)\n(max,+) 1.0\n\njulia> x.λ\n1.0\n\njulia> typeof(x.λ)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.star(::MP)","category":"page"},{"location":"maxplus/#MaxPlus.star-Tuple{MP}","page":"API: (max,+) Algebra","title":"MaxPlus.star","text":"star(x::MP)\n\nMake x a 1x1 matrix then call star(A::Array{MP}). See star(A::Array{MP}) for more information.\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.plus(::MP)","category":"page"},{"location":"maxplus/#MaxPlus.plus-Tuple{MP}","page":"API: (max,+) Algebra","title":"MaxPlus.plus","text":"plus(x::MP)\n\nMake x a 1x1 matrix then call plus(A::Array{MP}). See plus(A::Array{MP}) for more information.\n\nExamples\n\nFIXME\njulia> plus(MP(-1.0))\n(max,+) -1\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#(max,)-Constants","page":"API: (max,+) Algebra","title":"(max,+) Constants","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mp0","category":"page"},{"location":"maxplus/#MaxPlus.mp0","page":"API: (max,+) Algebra","title":"MaxPlus.mp0","text":"mp0\n\nCreate the constant (max,+) zero (equals to -∞, minus infinity) in classic algebra which is the neutral for the ⨁ operator. See also mpzero.\n\nEquivalent to ScicosLab code: %0 sugar notation for #(-%inf)\n\nExamples\n\njulia> mp0\n(max,+) -Inf\n\njulia> mp0 * 5\n(max,+) -Inf\n\njulia> mp0 + 5\n(max,+) 5\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.ε","category":"page"},{"location":"maxplus/#MaxPlus.ε","page":"API: (max,+) Algebra","title":"MaxPlus.ε","text":"ε (\\varepsilon)\n\nCreate the constant (max,+) zero (equals to -∞, minus infinity) in classic algebra which is the neutral for the ⨁ operator. See also mpzero.\n\nEquivalent to ScicosLab code: %0 sugar notation for #(-%inf)\n\nExamples\n\njulia> ε\n(max,+) -Inf\n\njulia> ε * 5\n(max,+) -Inf\n\njulia> ε + 5\n(max,+) 5\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mp1","category":"page"},{"location":"maxplus/#MaxPlus.mp1","page":"API: (max,+) Algebra","title":"MaxPlus.mp1","text":"mp1\n\nCreate the constant (max,+) one (equals to 0, zero) in classic algebra which is the neutral for operators ⨁ and ⨂. See also mpone.\n\nEquivalent to ScicosLab code: %1 sugar notation for #(1)\n\nExamples\n\njulia> mp1\n(max,+) 0\n\njulia> mp1 * 5\n(max,+) 5\n\njulia> mp1 + 5\n(max,+) 5\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mpe","category":"page"},{"location":"maxplus/#MaxPlus.mpe","page":"API: (max,+) Algebra","title":"MaxPlus.mpe","text":"mpe\n\nCreate the constant (max,+) one (equals to 0, zero) in classic algebra which is the neutral for operators ⨁ and ⨂. See also mpone.\n\nEquivalent to ScicosLab code: %1 sugar notation for #(1)\n\nExamples\n\njulia> mpe\n(max,+) 0\n\njulia> mpe * 5\n(max,+) 5\n\njulia> mpe + 5\n(max,+) 5\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mptop","category":"page"},{"location":"maxplus/#MaxPlus.mptop","page":"API: (max,+) Algebra","title":"MaxPlus.mptop","text":"mptop\n\nCreate the constant (min,+) one (equals to +∞, infinity) in classic algebra which is the neutral for operators ⨁ and ⨂.\n\nEquivalent to ScicosLab code: %top = #(%inf)\n\nExamples\n\njulia> mptop\n(max,+) Inf\n\njulia> mptop * 5\n(max,+) Inf\n\njulia> mptop + 5\n(max,+) Inf\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mpI","category":"page"},{"location":"maxplus/#MaxPlus.mpI","page":"API: (max,+) Algebra","title":"MaxPlus.mpI","text":"mpI\n\nAn object of type UniformScaling, representing a (max,+) identity matrix of any size. Is the equivalent of LinearAlgebra.I but for (max,+) type. Allow to create identity (max,+) matrices.\n\nExamples\n\njulia> typeof(mpI)\nLinearAlgebra.UniformScaling{MP}\n\njulia> set_tropical_display(0)\n\njulia> Matrix(mpI, 2, 2)\n2×2 (max,+) dense matrix:\n   0.0   -Inf\n  -Inf    0.0\n\njulia> set_tropical_display(1)\n\njulia> Matrix(mpI, 2, 2)\n2×2 (max,+) dense matrix:\n  0   .\n  .   0\n\njulia> using LinearAlgebra\n\njulia> Matrix(mpI, 2, 2) == Matrix{MP}(I, 2, 2)\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"maxplus/#(max,)-Dense-matrices-constructions","page":"API: (max,+) Algebra","title":"(max,+) Dense matrices constructions","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.ones(MP, m::Int64, n::Int64)\nBase.ones(MP, n::Int64)\nBase.ones(MP, A::Array)","category":"page"},{"location":"maxplus/#Base.ones-Tuple{Any, Int64, Int64}","page":"API: (max,+) Algebra","title":"Base.ones","text":"ones(MP, m::Int64, n::Int64)\n\nConstruct a (max,+) one m-by-n matrix.\n\nExamples\n\njulia> ones(MP, 3,2)\n3×2 (max,+) dense matrix:\n  0.0   0.0\n  0.0   0.0\n  0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.ones-Tuple{Any, Int64}","page":"API: (max,+) Algebra","title":"Base.ones","text":"ones(MP, n::Int64)\n\nConstruct a (max,+) one n-by-1 matrix.\n\nExamples\n\njulia> ones(MP, 2)\n2-element (max,+) vector:\n  0.0\n  0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.ones-Tuple{Any, Array}","page":"API: (max,+) Algebra","title":"Base.ones","text":"ones(MP, A::Array{T})\n\nConstruct a sparse (max,+) ones matrix of same dimension and of the same type that the matrix given as parameter.\n\nExamples\n\njulia> A=[1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> ones(MP, A)\n2×2 (max,+) dense matrix:\n  0.0   0.0\n  0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.zeros(MP, m::Int64, n::Int64)\nBase.zeros(MP, n::Int64)\nBase.zeros(MP, A::Array)","category":"page"},{"location":"maxplus/#Base.zeros-Tuple{Any, Int64, Int64}","page":"API: (max,+) Algebra","title":"Base.zeros","text":"zeros(MP, m::Int64, n::Int64)\n\nConstruct a (max,+) zero m-by-n (max,+) dense matrix.\n\nExamples\n\njulia> zeros(MP, 3,2)\n3×2 (max,+) dense matrix:\n  0.0   0.0\n  0.0   0.0\n  0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.zeros-Tuple{Any, Int64}","page":"API: (max,+) Algebra","title":"Base.zeros","text":"zeros(MP, n::Int64)\n\nConstruct a (max,+) zero n-by-1 (max,+) dense matrix.\n\nExamples\n\njulia> zeros(MP, 2)\n2-element (max,+) vector:\n  0.0\n  0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.zeros-Tuple{Any, Array}","page":"API: (max,+) Algebra","title":"Base.zeros","text":"zeros(MP, A::Array{T})\n\nConstruct a (max,+) zero dense matrix of same dimension and of the same type that the matrix given as parameter.\n\nExamples\n\njulia> A=[1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> zeros(MP, A)\n2×2 (max,+) dense matrix:\n  0.0   0.0\n  0.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.eye(MP, m::Int64, n::Int64)\nMaxPlus.eye(MP, n::Int64)\nMaxPlus.eye(MP, A::Array)","category":"page"},{"location":"maxplus/#MaxPlus.eye-Tuple{Any, Int64, Int64}","page":"API: (max,+) Algebra","title":"MaxPlus.eye","text":"eye(MP, m::Int64, n::Int64)\n\nConstruct a (max,+) identity dense m-by-n matrix.\n\nExamples\n\njulia> eye(MP, 2, 3)\n2×3 (max,+) dense matrix:\n   0.0   -Inf   -Inf\n  -Inf    0.0   -Inf\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#MaxPlus.eye-Tuple{Any, Int64}","page":"API: (max,+) Algebra","title":"MaxPlus.eye","text":"eye(MP, n::Int64)\n\nConstruct a (max,+) identity dense n-by-n matrix.\n\nExamples\n\njulia> eye(MP, 2)\n2×2 (max,+) dense matrix:\n   0.0   -Inf\n  -Inf    0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#MaxPlus.eye-Tuple{Any, Array}","page":"API: (max,+) Algebra","title":"MaxPlus.eye","text":"eye(MP, A::Array{T})\n\nConstruct a (max,+) identity dense matrix of same dimension and of the same type that the matrix given as parameter.\n\nExamples\n\njulia> A=[1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> eye(MP, A)\n2×2 (max,+) dense matrix:\n  0.0  -Inf\n -Inf   0.0\n\njulia> eye(MP, MP(A))\n2×2 (max,+) dense matrix:\n  0.0  -Inf\n -Inf   0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#(max,)-Sparse-matrices-constructions","page":"API: (max,+) Algebra","title":"(max,+) Sparse matrices constructions","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"SparseArrays.spzeros(MP, m::Int64, n::Int64)\nSparseArrays.spzeros(MP, n::Int64)\nSparseArrays.spzeros(MP, A::Array)","category":"page"},{"location":"maxplus/#SparseArrays.spzeros-Tuple{Any, Int64, Int64}","page":"API: (max,+) Algebra","title":"SparseArrays.spzeros","text":"spzeros(MP, n::Int64)\n\nConstruct a sparse (max,+) zero m-by-n matrix.\n\nExamples\n\njulia> using SparseArrays\n\njulia> spzeros(MP, 2,5)\n2×5 SparseMatrixCSC{MP,Int64} with 0 stored entries\n  .   .   .   .   .\n  .   .   .   .   .\n\njulia> full(spzeros(MP, 2,5))\n2×5 (max,+) dense matrix:\n  -Inf   -Inf   -Inf   -Inf   -Inf\n  -Inf   -Inf   -Inf   -Inf   -Inf\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#SparseArrays.spzeros-Tuple{Any, Int64}","page":"API: (max,+) Algebra","title":"SparseArrays.spzeros","text":"spzeros(MP, n::Int64)\n\nConstruct a (max,+) zero n-by-m sparse matrix.\n\nExamples\n\njulia> using SparseArrays\n\njulia> spzeros(MP, 2)\n2-element SparseVector{MP,Int64} with 0 stored entries\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#SparseArrays.spzeros-Tuple{Any, Array}","page":"API: (max,+) Algebra","title":"SparseArrays.spzeros","text":"spzeros(MP, A::Array{T})\n\nConstruct a sparse  (max,+) zero matrix of same dimension and of the same type that the matrix given as parameter.\n\nExamples\n\njulia> using SparseArrays\n\njulia> A=[1.0 2; 3 4]\n2×2 Matrix{Float64}:\n 1.0  2.0\n 3.0  4.0\n\njulia> spzeros(MP, A)\n2×2 (max,+) sparse matrix with 0 stored entries:\n  .   .\n  .   .\n\njulia> spzeros(MP, MP(A))\n2×2 (max,+) sparse matrix with 0 stored entries:\n  .   .\n  .   .\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.speye(MP, m::Int64, n::Int64)\nMaxPlus.speye(MP, n::Int64)","category":"page"},{"location":"maxplus/#MaxPlus.speye-Tuple{Any, Int64, Int64}","page":"API: (max,+) Algebra","title":"MaxPlus.speye","text":"speye(MP, m::Int64, n::Int64)\n\nConstruct a (max,+) identity sparse m-by-n matrix.\n\nExamples\n\njulia> speye(MP, 2, 3)\n2×3 (max,+) sparse matrix with 2 stored entries:\n  [1, 1]  =  0.0\n  [2, 2]  =  0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#MaxPlus.speye-Tuple{Any, Int64}","page":"API: (max,+) Algebra","title":"MaxPlus.speye","text":"speye(MP, n::Int64)\n\nConstruct a (max,+) identity sparse n-by-n matrix.\n\nExamples\n\njulia> speye(MP, 2)\n2×2 (max,+) sparse matrix with 2 stored entries:\n  [1, 1]  =  0.0\n  [2, 2]  =  0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#(max,)-matrices-Conversion","page":"API: (max,+) Algebra","title":"(max,+) matrices Conversion","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.plustimes(A::Array{MP})","category":"page"},{"location":"maxplus/#MaxPlus.plustimes-Tuple{Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"MaxPlus.plustimes","text":"plustimes(A::Array{MP})\n\nConvert a (max,+) dense matrix to a dense matrix in standard algebra.\n\nExamples\n\njulia> A = [MP(1.0) 2.0; ε mpe]\n2×2 (max,+) dense matrix:\n  1   2\n  .   0\n\njulia> plustimes(A)\n2×2 Matrix{Float64}:\n   1.0  2.0\n  -Inf  0.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.plustimes(S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.plustimes-Tuple{SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.plustimes","text":"plustimes(A::SparseMatrixCSC{MP})\n\nConvert a (max,+) sparse matrix to an sparse matrix in standard algebra.\n\nExamples\n\njulia> using SparseArrays\n\njulia> S = sparse(eye(MP, 2,2))\n2×2 Max-Plus sparse matrix with 2 stored entries:\n  [1, 1]  =  0\n  [2, 2]  =  0\n\njulia> findnz(S)\n([1, 2], [1, 2], MP[0, 0])\n\njulia> plustimes(S)\n2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 0.0   ⋅\n  ⋅   0.0\n\njulia> findnz(plustimes(S))\n([1, 2], [1, 2], [0.0, 0.0])\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.full(S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.full-Tuple{SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.full","text":"full(::SparseMatrixCSC{MP}})\n\nConvert a sparse (max,+) array to a dense (max,+) array. Alternative function name: dense.\n\nExamples\n\njulia> using SparseArrays\n\njulia> set_tropical_display(0)\n\njulia> full(spzeros(MP, 2,5))\n2×5 (max,+) dense matrix:\n  -Inf   -Inf   -Inf   -Inf   -Inf\n  -Inf   -Inf   -Inf   -Inf   -Inf\n\njulia> set_tropical_display(1)\n\njulia> full(spzeros(MP, 2,5))\n2×5 (max,+) dense array:\n  .   .   .   .   .\n  .   .   .   .   .\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.dense(S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.dense-Tuple{SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.dense","text":"dense(::SparseMatrixCSC{MP}})\n\nConvert a sparse (max,+) array to a dense (max,+) array. Alternative function name: full.\n\nExamples\n\njulia> using SparseArrays\n\njulia> set_tropical_display(0)\n\njulia> dense(spzeros(MP, 2,5))\n2×5 (max,+) dense array:\n -Inf  -Inf  -Inf  -Inf  -Inf\n -Inf  -Inf  -Inf  -Inf  -Inf\n\njulia> set_tropical_display(1)\n\njulia> dense(spzeros(MP, 2,5))\n2×5 (max,+) dense matrix:\n  .   .   .   .   .\n  .   .   .   .   .\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#(max,)-Matrix-operations","page":"API: (max,+) Algebra","title":"(max,+) Matrix operations","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(\\)(::AbstractMatrix{MP}, ::AbstractMatrix{MP})\nBase.:(\\)(::AbstractMatrix{MP}, ::MP)\nBase.:(\\)(::MP, ::AbstractMatrix{MP})","category":"page"},{"location":"maxplus/#Base.:\\-Tuple{AbstractMatrix{MP}, AbstractMatrix{MP}}","page":"API: (max,+) Algebra","title":"Base.:\\","text":"\\(A::AbstractMatrix{MP}, b::AbstractMatrix{MP})\n\nx = A \\ b is a solution to A ⨂ x = b and its simply computed as inv(A) * b.\n\nExamples\n\njulia> A = [mp0 1 mp0; 2 mp0 mp0; mp0 mp0 3]\n3×3 (max,+) dense matrix:\n  .   1   .\n  2   .   .\n  .   .   3\n\njulia> B = [3 mp0 mp0; mp0 mp0 4; mp0 5 mp0]\n3×3 (max,+) dense matrix:\n  3   .   .\n  .   .   4\n  .   5   .\n\njulia> x = A \\ B\n3×3 (max,+) dense matrix:\n  .   .   2\n  2   .   .\n  .   2   .\n\njulia> A * x == B\ntrue\n\njulia> A \\ A\n3×3 (max,+) dense matrix:\n  0   .   .\n  .   0   .\n  .   .   0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.:\\-Tuple{AbstractMatrix{MP}, MP}","page":"API: (max,+) Algebra","title":"Base.:\\","text":"Base.:(\\)(A::AbstractMatrix{MP}, b::MP)\n\nTODO\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.:\\-Tuple{MP, AbstractMatrix{MP}}","page":"API: (max,+) Algebra","title":"Base.:\\","text":"Base.:(\\)(A::MP, b::AbstractMatrix{MP})\n\nTODO\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.:(/)(::AbstractMatrix{MP}, ::AbstractMatrix{MP})\nBase.:(/)(::AbstractMatrix{MP}, ::MP)\nBase.:(/)(::MP, ::AbstractMatrix{MP})","category":"page"},{"location":"maxplus/#Base.:/-Tuple{AbstractMatrix{MP}, AbstractMatrix{MP}}","page":"API: (max,+) Algebra","title":"Base.:/","text":"Base.:(/)(A::AbstractMatrix{MP}, B::AbstractMatrix{MP})\n\nTODO\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.:/-Tuple{AbstractMatrix{MP}, MP}","page":"API: (max,+) Algebra","title":"Base.:/","text":"Base.:(/)(A::AbstractMatrix{MP}, b::MP)\n\nTODO\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.:/-Tuple{MP, AbstractMatrix{MP}}","page":"API: (max,+) Algebra","title":"Base.:/","text":"Base.:(/)(a::MP, b::AbstractMatrix{MP})\n\nTODO\n\nExamples\n\njulia>\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"Base.inv(::Matrix{MP})","category":"page"},{"location":"maxplus/#Base.inv-Tuple{Matrix{MP}}","page":"API: (max,+) Algebra","title":"Base.inv","text":"inv(A::Array{MP})\n\nReturn the inverse of a scalar or a (max,+) matrix which is transpose(-A).\n\nExample 1: Scalar\n\njulia> inv(MP(5))\n(max,+) -5\n\njulia> MP(5)^-1\n(max,+) -5\n\njulia> MP(5)^0\n(max,+) 0\n\nExample 2: Square matrix inversible\n\njulia> A = [mp0 1 mp0; 2 mp0 mp0; mp0 mp0 3]\n3×3 (max,+) dense matrix:\n  .   1   .\n  2   .   .\n  .   .   3\n\njulia> A^-1\n3×3 (max,+) transpose(dense matrix):\n   .   -2    .\n  -1    .    .\n   .    .   -3\n\njulia> inv(A)\n3×3 (max,+) dense matrix:\n   .   -2    .\n  -1    .    .\n   .    .   -3\n\njulia> A * inv(A)\n3×3 (max,+) dense matrix:\n  0   .   .\n  .   0   .\n  .   .   0\n\njulia> A * inv(A) == inv(A) * A == eye(A)\ntrue\n\nExample 3: Square matrix inversible\n\njulia> A = [mp0 1 mp0; 2 mp0 mp0]\n2×3 (max,+) dense matrix:\n  .   1   .\n  2   .   .\n\njulia> A^-1\n3×2 (max,+) dense matrix:\n   .   -2\n  -1    .\n   .    .\n\njulia> inv(A)\n3×2 (max,+) dense matrix:\n   .   -2\n  -1    .\n   .    .\n\njulia> A * inv(A)\n2×2 (max,+) dense matrix:\n  0   .\n  .   0\n\njulia> inv(A) * A\n3×3 (max,+) dense matrix:\n  0   .   .\n  .   0   .\n  .   .   .\n\njulia> (A * inv(A)) != (inv(A) * A)\ntrue\n\nExample 4: Non inversible\n\njulia> A = MP([1 2; 3 4])\n2×2 (max,+) dense matrix:\n  1   2\n  3   4\n\njulia> inv(A)\n2×2 (max,+) dense matrix:\n  -1   -3\n  -2   -4\n\njulia> (A * inv(A)) != eye(A)\ntrue\n\njulia> (inv(A) * A) != eye(A)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.star(A::Array{MP})","category":"page"},{"location":"maxplus/#MaxPlus.star-Tuple{Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"MaxPlus.star","text":"B = star(A::Array{MP})\n\nSolve x = Ax + I in the (max,+) algebra. When there is no circuits with positive weight in G(A) (the incidence graph of A) B = I + A + ... + A^(n-1) where n denotes the order of the square matrix A.\n\nSee also plus.\n\nArguments\n\nA : (max,+) full square matrix.\nB : Id + A + A^2 + ...\n\nExamples\n\njulia> star(MP(1.0))\n(max,+) Inf\n\njulia> star(MP(-1.0))\n(max,+) 0\n\njulia> star(MP([1.0 2; 3 4]))\n2×2 (max,+) dense matrix:\n  Inf   Inf\n  Inf   Inf\n\njulia> A = star(MP([-3.0 -2;-1 0]))\n2×2 (max,+) dense matrix:\n   0   -2\n  -1    0\n\njulia> B = star(A)\n2×2 (max,+) dense matrix:\n   0   -2\n  -1    0\n\njulia> B == (eye(MP, 2,2) + A)\ntrue\n\njulia> B == (B + A * A)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.plus(A::Array{MP})","category":"page"},{"location":"maxplus/#MaxPlus.plus-Tuple{Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"MaxPlus.plus","text":"B = plus(A::Array{MP})\n\nCompute A * A^* = A + A^2 + ... of a maxplus matrix A. See also star.\n\nArguments\n\nA : (max,+) full square matrix.\nB : Id + A + A^2 + ...\n\nExamples\n\njulia> plus(MP(1.0))\n(max,+) Inf\n\nFIXME\njulia> A = MP([-3.0 -2; -1 0])\n2×2 (max,+) dense matrix:\n  -3   -2\n  -1    0\n\njulia> B = plus(A)\n2×2 (max,+) dense matrix:\n   0   -2\n  -1    0\n\njulia> B == (A * star(A))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.astarb(A::Array{MP}, b::Array{MP})","category":"page"},{"location":"maxplus/#MaxPlus.astarb-Tuple{Array{MP, N} where N, Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"MaxPlus.astarb","text":"astarb(A::Array{MP}, b::Array{MP})\n\n(max,+) linear system solution.\n\nSolve x = Ax + b in the (max,+) algebra when there is no circuits with positive weight in G(A') (the incidence graph of A', that is it exists an arc from j to i if A_ij is nonzero).\n\nTODO It is much more efficient in time and memory than star(A) * b.\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.mpeigen","category":"page"},{"location":"maxplus/#MaxPlus.mpeigen","page":"API: (max,+) Algebra","title":"MaxPlus.mpeigen","text":"λ,v = mpeigen(S::SparseMatrixCSC{MP})\nλ,v = mpeigen(S::Matrix{MP})\n\n(max,+) mpeigenvalues mpeigenvectors (interface the Howard algorithm):\n\nλ: mpeigenvalues\nv: mpeigenvectors\n\nExample:\n\njulia> using SparseArrays, LinearAlgebra\n\njulia> A = MP([1 2; 3 4])\n2×2 (max,+) dense matrix:\n  1   2\n  3   4\n\njulia> λ,v = mpeigen(A)\n(MP[4, 4], MP[2, 4])\n\n# λ is constant\njulia> (A * v) == (λ[1] * v)\ntrue\n\nExample 2: Two blocks diagonal matrix.\n\njulia> using SparseArrays, LinearAlgebra\n\njulia> S = sparse([mp0 2 mp0; mp1 mp0 mp0; mp0 mp0 2])\n3×3 (max,+) sparse matrix with 3 stored entries:\n  [2, 1]  =  0\n  [1, 2]  =  2\n  [3, 3]  =  2\n\njulia> λ,v = mpeigen(S)\n(MP[1, 1, 2], MP[1, 0, 2])\n\n# The entries of λ take two values\njulia> (S / diagm(λ)) * v == v\ntrue\n\nExample 3: Block triangular matrix with 2 mpeigenvalues.\n\njulia> S = sparse([1 1; mp0 2])\n2×2 (max,+) sparse matrix with 3 stored entries:\n  [1, 1]  =  1\n  [1, 2]  =  1\n  [2, 2]  =  2\n\njulia> λ,v = mpeigen(S)\n(MP[2, 2], MP[1, 2])\n\njulia> (S * v) == (λ[1] * v)\ntrue\n\n# But MP(1) is also mpeigen value\njulia> S * [0; mp0] == MP(1) * [0; mp0]\ntrue\n\nExample 4: Block triangular matrix with 1 mpeigenvalue\n\njulia> using SparseArrays, LinearAlgebra\n\njulia> S = sparse([2 1; mp0 mp1])\n2×2 (max,+) sparse matrix with 3 stored entries:\n  [1, 1]  =  2\n  [1, 2]  =  1\n  [2, 2]  =  0\n\njulia> λ,v = mpeigen(S)\n(MP[2, 0], MP[2, 0])\n\n# λ is not constant λ[1] is mpeigen value\n# with mpeigen vector [v(1);0]\njulia> (S / diagm(λ)) * v == v\ntrue\n\n\n\n\n\n","category":"function"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.howard(S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.howard-Tuple{SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.howard","text":"[λ,v,p,c,n] = howard(S::SparseMatrixCSC{MP})\n\n(max,+) mpeigenvalues mpeigenvectors (Howard algorithm).\n\nMaxplus right mpeigenvalues and mpeigenvectors of a full or sparse maxplus matrix by Howard algorithm. The mpeigenvalues are considered as the average cost per unit of time for the corresponding dynamic programming problem.\n\nThe values taken by the entries of λ are the mpeigenvalues. If S is irreducible, λ is constant, it is the mpeigenvalue and v is a corresponding mpeigenvector (in this case, there exits only one mpeigenvalue but more than one mpeigenvectors may exist).\n\nOtherwise, S can be decomposed into irreducible components (in a certain numbering of rows and columns, it becomes block-triangular with diagonal irreducible blocks), λ is constant over each component and this constant is the mpeigenvalue, the corresponding entries of v, completed by -inf for the other blocks, provide a corresponding mpeigenvector.\n\np gives an optimal policy which satisfies S_ip(i) v_p(i) = λ + v_i\n\nRemark:\n\nFor the block triangular case, take a look at the examples to see what happen precisely on the transient block. All the mpeigen values are not found and the support of the mpeigenvectors depends of the mpeigenvalues of the blocks.\nFor the block diagonal case all the mpeigen values are found and the support of the mpeigenvectors are clear.\n\nOutputs:\n\nλ: mpeigenvalues\nv: mpeigenvectors\np: optimal policy (indices of the saturating entries of S)\nc: number of connected components of the optimal policy\nn: number of iterations of Howard algorithm\n\nExample:\n\njulia> using SparseArrays\n\njulia> A = MP([1 2; 3 4])\n2×2 (max,+) dense matrix:\n  1   2\n  3   4\n\njulia> r = howard(sparse(A))\nMaxPlus.HowardResult(MP[4, 4], MP[2, 4], [2, 2], 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.tr(A::Array{MP})","category":"page"},{"location":"maxplus/#LinearAlgebra.tr-Tuple{Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"LinearAlgebra.tr","text":"tr(A::Array{MP})\n\nCompute the trace of the matrix (summation of diagonal elements).\n\nExamples\n\njulia> tr([MP(1) 2; 3 4])\n(max,+) 4.0\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.norm(A::Array{MP})","category":"page"},{"location":"maxplus/#LinearAlgebra.norm-Tuple{Array{MP, N} where N}","page":"API: (max,+) Algebra","title":"LinearAlgebra.norm","text":"norm(A::Array{MP})\n\nCompute the norm of the full or sparce matrix A. Return the largest entry minus smallest entry of A.\n\nExamples\n\njulia-repl\njulia> using SparseArrays\n\njulia> A = MP([1 20 2;30 400 4;4 50 10])\n3×3 (max,+) dense matrix:\n   1.0    20.0    2.0\n  30.0   400.0    4.0\n   4.0    50.0   10.0\n\njulia> S = MP(sparse(A))\n3×3 (max,+) sparse matrix with 9 stored entries:\n   1    20    2\n  30   400    4\n   4    50   10\n\njulia> mpnorm(A)\n(max,+) 399\n\njulia> mpnorm(S)\n(max,+) 399\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.spget(S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.spget-Tuple{SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.spget","text":"(IJ, A, nnodes, narcs) = spget(S::SparseMatrixCSC)\n\nSparse description of a matrix.\n\nInspired by Silab [ij,a,s]=spget(sparse([1 %0; 3 4])) but return (I,J) on a vector, MaxPlus number for A are converted into classic number and number of node and number of arcs instead of matrix dimension.\n\nExamples\n\njulia> S = sparse([1.0 mp0; 3 4])\n2×2 (max,+) sparse matrix with 3 stored entries:\n  [1, 1]  =  1\n  [2, 1]  =  3\n  [2, 2]  =  4\n\njulia> spget(S)\n([1, 1, 2, 1, 2, 2], [1.0, 3.0, 4.0], 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.sparse_map(f, S::SparseMatrixCSC{MP})","category":"page"},{"location":"maxplus/#MaxPlus.sparse_map-Tuple{Any, SparseMatrixCSC{MP, Ti} where Ti<:Integer}","page":"API: (max,+) Algebra","title":"MaxPlus.sparse_map","text":"sparse_map(f, S::SparseMatrixCSC{MP})\n\nMap a function ot each element of the (max,+) sparse matrix.\n\nExamples\n\njulia> using SparseArrays\n\njulia> sparse_map(x -> x.λ, sparse(MP([1.0 0; 0 1.0])))\n2×2 SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n 1.0  0.0\n 0.0  1.0\n\njulia> sparse_map(x -> MP(x), sparse([1.0 0; 0 1.0]))\n2×2 Max-Plus sparse matrix with 2 stored entries:\n  [1, 1]  =  1\n  [2, 2]  =  1\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Display-control-of-(max,)-scalar-and-Matrices","page":"API: (max,+) Algebra","title":"Display control of (max,+) scalar and Matrices","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"MaxPlus.set_tropical_display\nMaxPlus.LaTeX(io::IO, A::Matrix{MP})\n\n#Base.show(::IO, ::Matrix{MP})\n#Base.show(::IO, ::SparseMatrixCSC{MP})\n\nBase.show(::IO, ::MIME\"text/plain\", A::Matrix{MP})\nBase.show(::IO, ::MIME\"text/latex\", A::Matrix{MP})","category":"page"},{"location":"maxplus/#MaxPlus.set_tropical_display","page":"API: (max,+) Algebra","title":"MaxPlus.set_tropical_display","text":"set_tropical_display(style::Int)\n\nChange the style of behavior of functions Base.show():\n\n-Inf are displayed either with ε (style 2 or 3) or . symbols (style 1).\n0 are displayed either with e (style 3) or '0' symbols (style 1 or 2).\nelse: -Inf and 0 are displayed in Julia default sytle (style 0).\n\nIf this function is not called, by default the ScicosLab style will be used (style 1).\n\nExamples\n\njulia> set_tropical_display(0)\nI will show -Inf and 0.0\n\njulia> eye(MP, 3, 3)\n3×3 (max,+) dense matrix:\n   0.0   -Inf   -Inf\n  -Inf    0.0   -Inf\n  -Inf   -Inf    0.0\n\njulia> set_tropical_display(1)\nI will show -Inf as .\n\njulia> eye(MP, 3, 3)\n3×3 (max,+) dense matrix:\n  0   .   .\n  .   0   .\n  .   .   0\n\njulia> set_tropical_display(2)\nI will show -Inf as . and 0.0 as e\n\njulia> eye(MP, 3, 3)\n3×3 (max,+) dense matrix:\n  e   .   .\n  .   e   .\n  .   .   e\n\njulia> set_tropical_display(3)\nI will show -Inf as ε\n\njulia> eye(MP, 3, 3)\n3×3 (max,+) dense matrix:\n  0   ε   ε\n  ε   0   ε\n  ε   ε   0\n\njulia> set_tropical_display(4)\nI will show -Inf as ε and 0.0 as e\n\njulia> eye(MP, 3, 3)\n3×3 (max,+) dense matrix:\n  e   ε   ε\n  ε   e   ε\n  ε   ε   e\n\n\n\n\n\n","category":"function"},{"location":"maxplus/#MaxPlus.LaTeX-Tuple{IO, Matrix{MP}}","page":"API: (max,+) Algebra","title":"MaxPlus.LaTeX","text":"LaTeX(io::IO, A::Array{MP})\n\nBase function for convert a Max-Plus dense matrix to a LaTeX formula. Symbols of neutral and absorbing elements depends on settropicaldisplay(style).\n\nExamples\n\njulia> LaTeX(stdout, MP([4 3; 7 -Inf]))\n\\left[\n\\begin{array}{*{20}c}\n4 & 3 \\\\\n7 & . \\\\\n\\end{array}\n\\right]\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Matrix{MP}}","page":"API: (max,+) Algebra","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", A::Matrix{MP})\n\nDisplay a tropical array on the desired output (i.e. console). Controled by settropicaldisplay().\n\nExamples\n\n\njulia> set_tropical_display(4)\nI will show -Inf as ε and 0.0 as e\n\njulia> show(stdout, \"text/plain\", MP([1 0; -Inf 6]))\n2×2 (max,+) dense matrix:\n  1   e\n  ε   6\n\njulia> set_tropical_display(0)\nI will show -Inf and 0.0\n\njulia> show(stdout, \"text/plain\", MP([1 0; -Inf 6]))\n2×2 (max,+) dense matrix:\n  1   0\n  .   6\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Base.show-Tuple{IO, MIME{Symbol(\"text/latex\")}, Matrix{MP}}","page":"API: (max,+) Algebra","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/latex\", A::Matrix{MP})\n\nGenerate the \\LaTeX formula from the given tropical array. Controled by settropicaldisplay().\n\nExamples\n\njulia> set_tropical_display(4)\nI will show -Inf as ε and 0.0 as e\n\njulia> show(stdout, \"text/latex\", MP([1 0; -Inf 6]))\n\\left[\n\\begin{array}{*{20}c}\n1 & e \\\\\n\\varepsilon & 6 \\\\\n\\end{array}\n\\right]\n\njulia> set_tropical_display(0)\nI will show -Inf and 0.0\n\njulia> show(stdout, \"text/latex\", MP([1 0; -Inf 6]))\n\\left[\n\\begin{array}{*{20}c}\n1 & 0 \\\\\n-\\infty & 6 \\\\\n\\end{array}\n\\right]\n\n\n\n\n\n","category":"method"},{"location":"maxplus/#Index","page":"API: (max,+) Algebra","title":"Index","text":"","category":"section"},{"location":"maxplus/","page":"API: (max,+) Algebra","title":"API: (max,+) Algebra","text":"","category":"page"},{"location":"bibliography/#Bibliography-and-references","page":"Bibliography","title":"Bibliography and references","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"The book SYNCHRONIZATION AND LINEARITY: An Algebra for Discrete Event Systems can be downloaded for free. The Scilab toolbox is based on this book.\nNSP or ScicosLab Homepage of the official Scilab fork developed by some of the researchers who originally developed Scilab at INRIA and ENPC. This version contains a Max-Plus toolbox. Inside NSP or ScicosLab you can run the Max-Plus demonstration. Go to the Demos menu and select Maxplus demos. A pdf tutorial is available here explaining the demo. For the help of Max-Plus functions type help and click on the Maxplus link. Note that the newer version of ScicosLab is named Nsp but does not contain directly the Max-Plus toolbox.\nStéphane Gaubert webpage in which you can find the C code source of the Howard algorithm (general \"maximal circuit mean\" problem, in directed graphs). You can watch his video, in French, introducing the (max,+) algebra and petri nets.\nJean-Pierre Quadrat Many English and French PDF documents about (max,+) algebra with applications can be found.\nJarosław Stańczyk gives a Matlab version (and/or GNU Octave) including a good introduction document to the Max-Plus algebra, modeling, analysis and control of Discrete Event Systems. His toolbox is available at this link I also made a fork of it.\nGiggle Liu An other Julia package for (max,+).","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: logo)","category":"page"},{"location":"#Julia's-(max,)-and-(min,)-Algebra-Toolbox","page":"Home","title":"Julia's (max,+) and (min,+) Algebra Toolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"The (max,+) algebra (or simply max-plus) redefines operators plus and times from the classical algebra to respective operators maximum (symbolized by ⨁) and times (symbolized by ⨂) in the domain of real numbers ℝ augmented by the number minus infinity -∞. The (min,+) algebra (min-plus) redefines operators plus and times from the classical algebra to respective operators minimum (symbolized by ⨁) and times (symbolized by ⨂) in the domain of real numbers ℝ augmented by the number minus infinity +∞.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The interest in matrix computation in this algebra is taught since 1960 by J. Kuntzman in his theory of networks. It is used in numerous domains such as operational research (network theory), physics (quantization), probabilities (Cramer's transform), law control (discrete events systems), computer science (automata theory, Petri nets), and mathematics (algebraic geometry). This algebra is also known as \"tropical algebra\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"This current Julia MaxPlus.jl package is a portage in Julia language of the ScicosLab's (max,+) toolbox which gave you functions for doing numerical computations in (max, +) algebra. Due to the young age of this toolbox, in case of doubt about obtained results, please compare them with ScicosLab results, and if they are not matching, report an issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This Julia toolbox extends the original toolbox by adding the (min, +) algebra. You may also be interested in this Timed Petri Net and Timed Event Graphs graphical editor which is also bound with (max, +) algebra. This editor can help you generate (max, +) matrices from timed event graphs.","category":"page"},{"location":"#Prerequisite","page":"Home","title":"Prerequisite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This MaxPlus.jl toolbox depends on the following Julia packages: Printf, PrettyTables, LinearAlgebra, SparseArrays. They are installed automatically by Julia's packager. The toolbox is supposed to work with any version of Julia >= 0.6.4 but a version >= 1.0 is the most recommended since older Julia versions are no longer maintained. Depending on the version of your Julia some importants issue in the core of Julia impacts this toolbox I had to add some fallbacks but they may interfere with other packages you are using with MaxPlus.jl.","category":"page"},{"location":"#Installation-of-the-Julia-(max,)-package-MaxPlus.jl","page":"Home","title":"Installation of the Julia (max,+) package MaxPlus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are different ways to install the package of this toolbox:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Get the stable MaxPlus.jl version of the package from the official Julia packages. Type ] then type add MaxPlus.\nGet the latest code source locally. From your Linux terminal type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/Lecrapouille/MaxPlus.jl.git --depth=1\ncd MaxPlus.jl\njulia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Be sure to be inside the root of the git repository. Then, from the Julia REPL type: ] then type add . The API may be in gestation and not be stable and changed from the available one in official Julia packages.","category":"page"},{"location":"#Your-first-(max,)-lines-of-code-in-the-REPL","page":"Home","title":"Your first (max,+) lines of code in the REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once the package has been installed, you have to activate the (max,+) package. From the Julia REPL, type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MaxPlus","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, you can type your first lines of (max, +) code inside the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> MP([1 2; 3 8]) .+ 5","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia will reply to you:","category":"page"},{"location":"","page":"Home","title":"Home","text":"2×2 (max,+) dense matrix:\n  5   5\n  5   8","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's understand how Julia has made its computation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, Julia creates a dense matrix of (max,+) numbers (typed MP): [MP(1) MP(2); MP(3) MP(8)]).\nFor each element of the matrix (the . operator), the ⨁ 5 will be applied.\nBefore the ⨁ is applied, the number 5 is converted to a (max,+) number MP(5).\nJulia Int64 and Float64 numbers are implicitly promoted to a (max,+) number (internally encoded as Float64).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Symbols ⨁ and ⨂ are not used to avoid complex formulas hard to type and hard to read, so keep using + and * symbols.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The equivalent of MP([1 2; 3 8]) .+ 5 in classical algebra is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"  [max(1, 5)  max(2, 5)\n   max(3, 5)  max(8, 5)]","category":"page"},{"location":"","page":"Home","title":"Home","text":"and shall not be confused with this formula [1 2; 3 8] .+ 5 in classical algebra computing:","category":"page"},{"location":"","page":"Home","title":"Home","text":"  [(1 + 5)  (2 + 5)\n   (3 + 5)  (8 + 5)]","category":"page"},{"location":"#Your-first-(min,)-lines-of-code-in-the-REPL","page":"Home","title":"Your first (min,+) lines of code in the REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This toolbox initially focused on the (max,+) algebra but one thing leading to another, functions for algebra (min,+) have been introduced but the name of the package MaxPlus.jl hasn't changed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For (min,+) numbers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> MI([1 2; 3 8])\n2×2 (min,+) dense matrix:\n  1   2\n  3   8","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Do you want to dive more about programming in (max,+) with this toolbox ? The following documents are compiled into a single online documentation: https://lecrapouille.github.io/MaxPlus.jl else within GitHub you can see them as Markdown:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Introduction and tutorials of this toolbox and tropical algebra in French and in English.\nThe index of (max,+) functions.\nThe index of (min,+) functions.\nThe index of (max,+) linear system.\nThe Rosetta Stone to translate SicosLab to MaxPlus.jl functions.\nFor developpers, you can run non regression tests.\nA Timed Petri net and graph event editor, a separate project of mine in relation to (max,+) algebra.\nThe bibliography links to other documentation and ressources.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Feel free to contribute and particularly, since I'm more of a C++ guy, to help reworking the code using more Julia formalism.","category":"page"},{"location":"tutorial/#Tropical-Algebra-Tutorials-with-the-MaxPlus.jl-Toolbox","page":"MaxPlus.jl Tutorials","title":"Tropical Algebra Tutorials with the MaxPlus.jl Toolbox","text":"","category":"section"},{"location":"tutorial/","page":"MaxPlus.jl Tutorials","title":"MaxPlus.jl Tutorials","text":"Note: The notebooks are directly rendered from the website nbviewer but not from GitHub because LaTeX formulas are partially displayed with GitHub.","category":"page"},{"location":"tutorial/#Installation-and-usage-within-Jupyter","page":"MaxPlus.jl Tutorials","title":"Installation and usage within Jupyter","text":"","category":"section"},{"location":"tutorial/","page":"MaxPlus.jl Tutorials","title":"MaxPlus.jl Tutorials","text":"(Image: fr) French\n(Image: en) English","category":"page"},{"location":"tutorial/#(max,)-Introduction-with-Julia","page":"MaxPlus.jl Tutorials","title":"(max,+) Introduction with Julia","text":"","category":"section"},{"location":"tutorial/","page":"MaxPlus.jl Tutorials","title":"MaxPlus.jl Tutorials","text":"(Image: fr) French\n(Image: en) English","category":"page"},{"location":"tutorial/#(min,)-Introduction-with-Julia","page":"MaxPlus.jl Tutorials","title":"(min,+) Introduction with Julia","text":"","category":"section"},{"location":"tutorial/","page":"MaxPlus.jl Tutorials","title":"MaxPlus.jl Tutorials","text":"(Image: fr) French\n(Image: en) English","category":"page"},{"location":"tutorial/#Manipulation-of-(max,)-Dynamic-Linear-Systems-with-Julia","page":"MaxPlus.jl Tutorials","title":"Manipulation of (max,+) Dynamic Linear Systems with Julia","text":"","category":"section"},{"location":"tutorial/","page":"MaxPlus.jl Tutorials","title":"MaxPlus.jl Tutorials","text":"(Image: fr) French\n(Image: en) English coming soon.","category":"page"}]
}
